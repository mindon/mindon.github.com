<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Mindon | Mindon.IDEA]]></title>
  <link href="http://mindon.github.com/blog/categories/mindon/atom.xml" rel="self"/>
  <link href="http://mindon.github.com/"/>
  <updated>2012-05-19T16:07:06+08:00</updated>
  <id>http://mindon.github.com/</id>
  <author>
    <name><![CDATA[Mindon Feng]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Final solution]]></title>
    <link href="http://mindon.github.com/blog/2012/05/19/final-solution/"/>
    <updated>2012-05-19T12:21:00+08:00</updated>
    <id>http://mindon.github.com/blog/2012/05/19/final-solution</id>
    <content type="html"><![CDATA[<p><strong>若一切皆可實現，我們會如何解決眼前的問題？</strong>  -- 麥盾</p>

<p>对于这个问题的思考，大概是从讨论行人创红绿灯过马路的事情开始的。</p>

<p>前段时间看个视频，讨论关于道德的问题，看后同事Carl说道：这类选择本就与道德无关，均是基于自我保护（损害最小）的选择——真是一语道中了问题核心。</p>

<p>至少，若是方圆几里都没车的话，等人行绿灯就是个死板的傻行为，没什么值得称赞的。因为红绿灯系统并不是个很完善的产品。（对于闯红灯的认可，那些不要命想要跟汽车赛跑闯红灯的案例除外）</p>

<p>现在，让我们假设能做到一切，那么红绿灯系统改是怎么样的？</p>

<!--more-->


<p>【理想状态】不会在让人在道路上没车的时候等待！会根据道路的实际状况实时调整状态，让通行效率最高，等待时间最短。</p>

<p>【现实状态】系统没能达到理想状态，而作为行人的本身，却有能力做出调整——如在安全距离没车的情况之下闯人行道红灯——目的是实现通行效率最高，等待时间最短。</p>

<p>奇怪的是没人选择去骂做得并不好的规则和系统，倒是责怪起破坏规定却让系统更有效率的人了。</p>

<p>另外一个事情是在做web产品开发的时候碰到的，就是当一个句子过长的时候如何处理自动换行的问题。常规处理是：一切均自动换行。</p>

<p>咋看起来这样的处理不存在什么问题，现在解剖一下这样的处理方式的实质需求：</p>

<p>【理想状态】在尽量不破坏单词的情况下自动换行，即除非单词超出一行的长度，否则不应该破坏单词。</p>

<p>【现实状态】部分浏览器在自动换行处理上没能达到理想状态，即使单词超出一行的长度，也不自动分行显示。于是，大家干脆采用强制分行显示的方式，即不管长度单词，只要到达的行宽，一律把剩下的字母放到下一行。这样的后果就是很多正常的单词在行末惨遭拆分到两行显示。——问题是，超出行宽的单词少之又少，在一般的行宽内几乎是很难见到的，大多数是非正常输入导致（网址和公式除外）。也就是说这样的处理方式明明是为了极少数的异常输入的正常显示，而不惜去破坏大多数的正常输入的正常显示效果。（新浪微博刚发布的时候我就注意到了存在这样的问题。）</p>

<p>为了兼顾少数异常而不惜损害多数的正常，结果就是导致了更多的另一类异常。类似的情况其实在现实里并不少见。</p>

<p>最典型的就有两个社会现象：</p>

<ol>
<li><strong>计划生育</strong>，最大的问题是死守100年不变。（要說免稅100年不變，大家都是非常歡迎的）</li>
</ol>


<p>这个政策的制定的时候想必是正确的用来纠正之前的政策导致的不可控结果的。如今显得类似对癌之化疗：若是对健康之躯进行化疗，无疑等于谋杀。</p>

<p>现实状态下的政策死守无疑是对中华民族超长期延续的损害。民族基因样本的损失带来的长期破坏会是无法预计和估量的。即为修复短期异常，不惜破坏长期的正常进化和生命发展。</p>

<ol>
<li><strong>房地产市场</strong>，最大问题在对于投机的放任。</li>
</ol>


<p>国家能为了维持一个畸形的房地产市场的稳定，不惜损害广大人民群众的利益、自残信誉、破坏正常的实业发展氛围。——有点上了贼船下不来的感觉，不过更像电影里的一步踏错导致步步错的罪犯。</p>

<p>还有一个案例就是制度制定的现象。</p>

<p>【理想状态】制度规范流程、做法能保证少损失，高效率；</p>

<p>【现实状态】不完善的制度降低了效率，打击了积极性和创造性。典型的就是罚款制度。激励制度的效果相比之下远好于处罚制度，就是说如果规定中的处罚比激励更令人印象深刻的话，可能就需要反思一下了。</p>

<p>处罚只能抑制问题的发生，从来就没能真正解决过问题。法律和监狱就是个最典型的例子了，不过怎么加强处罚，都无法抑制犯罪的发生。</p>

<p>不管是做产品开发，或是制定规章制度，稍微套用一下『<strong>若一切皆可實現，我們會如何解決眼前的問題？</strong>』的思考，然后根据条件做到最近接理想状态的方案，就能避免很多弯路和不必要的问题和争论。</p>

<p>“选择总是基于自我损害最小和自我获利最大的平衡”——这个基本点用来分析和解读很多现象应该也会能找到很多不一样的结果，得到有利于解决问题的办法。</p>

<p>（Oct 17, 2010 <a href="http://mindon.appspot.com/blog/2010/10/16/best-solution.html">若一切都有可能，问题该如何解决？</a>）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Profiling Node.JS Application]]></title>
    <link href="http://mindon.github.com/blog/2012/04/26/profiling-nodejs-application/"/>
    <updated>2012-04-26T07:22:00+08:00</updated>
    <id>http://mindon.github.com/blog/2012/04/26/profiling-nodejs-application</id>
    <content type="html"><![CDATA[<h2>NodeJS</h2>

<p>Call something like "ulimit -n 8192" in your NodeJS App start shell script, before start your nodejs service.</p>

<p>Running with --prof to generate the v8.log</p>

<pre><code>node --prof --prof_lazy app.js
</code></pre>

<p>with tools in /node/deps/v8/, you can get report like following:</p>

<p>(run <code>tools/linux-tick-processor path-of-v8.log</code>)</p>

<pre><code>[Shared libraries]:
   ticks  total  nonlib   name
      3    0.0%    0.0%  .../libc-2.13.so

[JavaScript]:
   ticks  total  nonlib   name
      1    0.0%    0.0%  Stub: InstanceofStub

[C++]:
   ticks  total  nonlib   name
     1    0.0%    0.0%  __write
     ...

[GC]:
   ticks  total  nonlib   name
     15    0.0%

[Bottom up (heavy) profile]:
  Note: percentage shows a share of a particular caller in the total
  amount of its parent calls.
  Callers occupying less than 2.0% are not shown.

   ticks parent  name
   ...
</code></pre>

<p>trace log</p>

<pre><code>strace -o trace.log -cf node app.js:
</code></pre>

<p>or simple get the time</p>

<pre><code>time node app.js
</code></pre>

<h2>Other Modules &amp; Tools</h2>

<ul>
<li><a href="http://dtrace.org"><strong>dtrace</strong></a></li>
</ul>


<p>read the nodejs blog <a href="http://blog.nodejs.org/2012/04/25/profiling-node-js/">http://blog.nodejs.org/2012/04/25/profiling-node-js/</a></p>

<pre><code>dtrace -o stacks.out -n 'profile-97/execname == "node" &amp;&amp; arg1/{
  @[jstack(100, 8000)] = count(); } tick-60s { exit(0); }'
</code></pre>

<ul>
<li><strong>v8-profiler</strong></li>
</ul>


<p>@Github <a href="https://github.com/dannycoates/v8-profiler">https://github.com/dannycoates/v8-profiler</a></p>

<!--more-->


<pre><code>var profiler = require('v8-profiler');

profiler.startProfiling('startup');
slowStartupFoo();
profiler.stopProfiling('startup');

profiler.takeSnapshot('beforeLeak');
leakyFoo();
profiler.takeSnapshot('afterLeak');
</code></pre>

<ul>
<li><strong>node-inspector</strong></li>
</ul>


<p>@Github <a href="https://github.com/dannycoates/node-inspector">https://github.com/dannycoates/node-inspector</a></p>

<pre><code>node --debug app.js
</code></pre>

<ul>
<li><strong>node-profiler</strong></li>
</ul>


<p>@Github <a href="https://github.com/bnoordhuis/node-profiler">https://github.com/bnoordhuis/node-profiler</a></p>

<pre><code>var profiler = require('profiler');
//
// &lt;here be code you don't want to profile&gt;
//
profiler.resume();
//
// &lt;performance critical code here&gt;
//
profiler.pause();
</code></pre>

<ul>
<li><strong>Nodetime</strong>
<a href="http://nodetime.com/">http://nodetime.com/</a></li>
</ul>


<p>Nodetime reveals response time and other internals of HTTP requests and underlying HTTP / database calls in your Node.js application. Coupled with related process and OS state information it enables tracing performance problems down to the root cause. Nodetime supports multiple native and external APIs and libraries.</p>

<pre><code>var nodetime = require('nodetime');
nodetime.on('session', function(id) {
  // do something with session id here
});
nodetime.profile();
</code></pre>

<ul>
<li><strong>Callgrind</strong></li>
</ul>


<p>Callgrind is a profiling tool that records the call history among functions in a program's run as a call-graph. By default, the collected data consists of the number of instructions executed, their relationship to source lines, the caller/callee relationship between functions, and the numbers of such calls. Optionally, cache simulation and/or branch prediction (similar to Cachegrind) can produce further information about the runtime behavior of an application.</p>

<p><a href="http://valgrind.org/docs/manual/cl-manual.html">http://valgrind.org/docs/manual/cl-manual.html</a></p>

<pre><code>valgrind --tool=callgrind node app.js
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Aby is on the road: Lhasa]]></title>
    <link href="http://mindon.github.com/blog/2012/04/25/aby-is-on-the-road-lhasa/"/>
    <updated>2012-04-25T07:59:00+08:00</updated>
    <id>http://mindon.github.com/blog/2012/04/25/aby-is-on-the-road-lhasa</id>
    <content type="html"><![CDATA[<h2>Aby在路上…</h2>

<p>这一趟，Aby出门时间比较久。</p>

<p>先是飞由天津回家，在家里帮着忙活新装修的家选购家具什么的。</p>

<p>之后再经由天津往北京和可心汇合，考察大导咖啡馆的事宜，并准备一起前往西藏拉萨。</p>

<p>她们先是飞达西宁，在那去感受了一下青海湖——“早上的青海湖变了一个颜色，让人心悸的淡蓝。羊群跑上公路，水鸟飞起，如果是夏季定会更美。”（<a href="http://weibo.com/1416075644/yg3hZBuel">来源</a>）</p>

<p>接着就乘坐火车前往目的地——拉萨。</p>

<p>“坐上开往拉萨的列车，好好睡一觉，等待明天的美景。” （<a href="http://weibo.com/1416075644/yfZu49FvY">来源</a>）</p>

<!--more-->


<p>前往拉萨的火车旅途听说都是震撼之旅，感觉那会是刷新大脑的一个经历。</p>

<p>“早上醒来外面无边无际的白，一时分不清是雪还是盐，直到看到雪地加油站才确定是雪。不时看到远处有野驴、野牛、鹿还是藏羚羊？不禁感叹真是片神奇的土地！”（<a href="http://weibo.com/1416075644/yg3hZBuel">来源</a>）</p>

<p>若是我在这样的旅途中，可能会一整天都盯着车窗外面的天地，不知疲倦，去捕捉闪现眼前的那些由海拔就的景致和生命。</p>

<p>“到那曲看到下雪了，我还跑出去看了下”（短信）</p>

<p>Aby路途中带了一本书：</p>

<p>“感受到旅行的壮阔后，开始趴在中铺看《最好的时光在路上》，临走前麦盾推荐给我的书。序是‘旅行的意义’，只翻到第二页却开始泪流满面，不知是缅甸年青人的梦想，还是因为‘如果没有你，良辰美景堪舆谁说？’还是还是，被自然所震撼？还是，听到了自己？窗外的雪山变成了褐色的土地，突然不知道身在何处…”</p>

<p>旅行，我们习惯了一起，感受旅途、美景、美食——不同的天地景观，不一样的人文风俗。</p>

<p>我们相约在五一在成都碰面，休闲成都，然后一起回来。</p>

<p>今年的四月，是我们AND旅游的季节 :-)</p>

<hr />

<p>Aby，在拉萨，要注意休息，多喝水。健健康康、开开心心的！</p>

<p>这些日子的深圳 —— 刮风、下雨、缺少了Aby和美食 …</p>

<p>-- 麦盾，April 25, 2012 早晨，深圳</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Find out Unique Elements in a Javascript Array]]></title>
    <link href="http://mindon.github.com/blog/2012/04/17/find-out-unique-javascript-array-elements/"/>
    <updated>2012-04-17T22:53:00+08:00</updated>
    <id>http://mindon.github.com/blog/2012/04/17/find-out-unique-javascript-array-elements</id>
    <content type="html"><![CDATA[<p>To remove duplicate elements in a array, there are a few algorithms to implement.</p>

<h2>Algorithm 1</h2>

<pre><code>function unique1(d) {
  var o = {}, i, l = d.length, r = [];
  for(i=0; i&lt;l;i+=1) o[d[i]] = d[i];
  for(i in o) r.push(o[i]);
  return r;
};
</code></pre>

<p>This method has 2 loops, that's a big time-cost problem.</p>

<h2>Algorithm 2</h2>

<p>reduce one loop from the algorithm 1, improve a litter bit</p>

<pre><code>function unique2(d) {
  var r = [], i = {}, j = 0;
  for(var k=0, kmax=d.length; k&lt;kmax; k++) {
    if(!i[d[k]]) {
      i[d[k]] = 1;
      r[j++]=d[k];
    }
  }
  return r;
}
</code></pre>

<h2>Algorithm 3</h2>

<p>In ECMA-262 standard, there's a indexOf method for Array object, we use it to improve a lot.</p>

<pre><code>function unique3(d) {
  var r = [], j = 0;
  for(var k=0, kmax=d.length; k&lt;kmax; k++) {
    if(r.indexOf(d[k]) &lt; 0) {
      r[j++]=d[k];
    }
  }
  return r;
}
</code></pre>

<p>and it could be better...</p>

<!--more-->


<h2>Algorithm 4</h2>

<p>jQuery.unique source ( Sizzle.uniqueSort ), it's the fastest one.</p>

<pre><code>function unique4( d ) {
  d.sort();
  for (var i = 1; i &lt; d.length; i++ ) {
    if ( d[i] === d[ i - 1 ] ) {
      d.splice( i--, 1 );
    }
  }

  return d;
};
</code></pre>

<h2>Compare these 4 algorithms:</h2>

<p>Speed(Performance): 4 > 3 > 2 > 1</p>

<p>Testing code:</p>

<pre><code>var d = [1, 3, 2, '2'];

function test(fn, count) {
  var t = new Date().getTime();
  for(var k =0 ; k &lt; count; k++) {
    fn(d);
  }

  return new Date().getTime() - t;
}

var t1 = test(unique1, 100000);
var t2 = test(unique2, 100000);
var t3 = test(unique3, 100000);
var t4 = test(unique4, 100000);
</code></pre>

<p>Time consume result sample:</p>

<p>IE 9(in Editplus):</p>

<pre><code>[t1,t2,t3,t4] = [93, 55, 25, 25]
</code></pre>

<p>IE 9(Browser):</p>

<pre><code>[t1,t2,t3,t4] = [508, 449, 432, 271]
</code></pre>

<p>Chrome 18:</p>

<pre><code>[t1,t2,t3,t4] = [141, 59, 43, 43]
</code></pre>

<p>Firefox 11:</p>

<pre><code>[t1,t2,t3,t4] = [129, 118, 25, 37]
</code></pre>

<p>(use == instead of === in unique4 will make it a little bit faster.)</p>

<h2>Problems</h2>

<p>handling a array with different data types:</p>

<pre><code>var d = [1, 3, 2, '2'];
</code></pre>

<p>results:</p>

<pre><code>unique1(d) : [1, '2', 3]

unique2(d) : [1, 3, 2]

unique3(d) : [1, 3, 2, '2']

unique4(d) : [1, 2, '2', 3]
</code></pre>

<p>if we change the === in unique4 into ==, then the new result will be</p>

<pre><code>unique4(d) : [1, 2, 3]
</code></pre>

<p>Another issue is the order problem:</p>

<p>unique1 and unique4 will re-order elements.</p>

<p>unique2 and unique3 will keep the original order.</p>

<p>Algorithm 3: unique3 depends on indexOf of ECMA-262 standard implement, and it cannot handle different data types.</p>

<h2>Conclusion</h2>

<ul>
<li>Same data-type elements</li>
</ul>


<p>orgianl order: <strong>unique3</strong></p>

<p>sorted: <strong>unique4</strong></p>

<ul>
<li>Different data-type elements ( thinking '2' is the same as 2 )</li>
</ul>


<p>orgianl order: <strong>unique2</strong></p>

<p>sorted: <strong>unique4</strong> (!NOTICE: change === into == )</p>

<ul>
<li>Different data-type elements ( thinking '2' is different from 2 )</li>
</ul>


<p>orgianl order: <strong>unique3</strong></p>

<p>sorted: <strong>unique4</strong> (!NOTICE: keep === )</p>

<p>以上为去除数组中的重复元素的各种算法，性能及问题。</p>

<p>--- Mindon(麦盾) Apri 18, 2012 Shenzhen(深圳)</p>

<p>（整理这样一篇东西还挺耗时的，子时了zZzZZz... ）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[外出Aby发回的菜谱]]></title>
    <link href="http://mindon.github.com/blog/2012/04/17/abys-menu/"/>
    <updated>2012-04-17T22:41:00+08:00</updated>
    <id>http://mindon.github.com/blog/2012/04/17/abys-menu</id>
    <content type="html"><![CDATA[<p>Aby 不在身边，吃饭的事情也不能马虎了。给我特意准备了菜单，提醒我注意饮食：</p>

<hr />

<h2>早餐选择：</h2>

<p>1、花卷+豆浆</p>

<p>2、牛奶+吐司（夹蛋）</p>

<p>吐司可从岁宝可颂坊买，或者买白吐司。</p>

<p>3、粥</p>

<p>可配菜：</p>

<p>香菜炒蛋、酱炒蛋（冰箱里有）</p>

<!--more-->


<p>4、面条：冰箱里的细面</p>

<p>1）先煎蛋，双面煎，不用煎特别透，盛出</p>

<p>2）加水煮面，水开后5分钟左右，加入青菜，至熟，加盐，淋芝麻油。</p>

<p>5、意粉</p>

<p>1）可先煎蛋</p>

<p>2）加水煮意粉，可加些胡萝卜、黄瓜块。</p>

<p>6、云吞</p>

<p>煮熟可加香菜、虾皮，淋芝麻油。</p>

<h2>正餐：</h2>

<p>1、排骨汤</p>

<p>买扇骨，可加花生、马蹄</p>

<p>配料：玉竹、百合、党参、淮山 （冰箱里有）</p>

<p>2、苦瓜炒蛋 或炒肉片 （做法同，可加适量酱油）</p>

<p>1）苦瓜过水</p>

<p>2）炒蛋盛出</p>

<p>3）再加油炒苦瓜，放入鸡蛋，调盐。</p>

<p>3、小瓜炒蛋/肉</p>

<p>1）切蒜备用</p>

<p>2）炒蛋或肉，盛出。如炒肉，肉需先用淀粉、料酒腌下</p>

<p>3）加油，先炒蒜，加入小瓜，加入肉，加少许酱油，盐、芝麻油。</p>

<p>4、黄花菜炒肉</p>

<p>黄花菜放在橱柜最下面放调料的抽屉。炒法同上。</p>

<p>5、香菇炒肉</p>

<p>1）肉切片，拿少许淀粉、酱油、香油腌5分钟</p>

<p>2）香菇1切2块，葱切小段</p>

<p>3）放油，炒肉，变色盛出</p>

<p>4）下香菇，放少许料酒、酱油，炒至有出水情况，放入肉片，加盐、淋芝麻油，加小葱出锅。</p>

<p>6、拌黄瓜</p>

<p>黄瓜削皮，切蒜末，放入盐、酱油少许、醋、芝麻油。</p>

<p>7、素炒豆芽</p>

<p>8、木须肉</p>

<p>1）泡发木耳</p>

<p>2）1个鸡蛋打散，炒蛋，盛出</p>

<p>3）肉切片，用少许淀粉、酱油、香油腌一下</p>

<p>4）炒肉至变色，盛出</p>

<p>5）加油，加入葱（大葱）、姜丝炝锅，炒木耳，3分钟左右，再放入肉片，加入酱油少许，放入鸡蛋，放盐、淋芝麻油，出锅。</p>

<hr />

<p>材料、做法和步骤都给列出来了 :-)</p>

<p>嗯，一定会参考着来喂好自己的。</p>
]]></content>
  </entry>
  
</feed>
