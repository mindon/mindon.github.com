<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Mindon | Mindon.IDEA]]></title>
  <link href="http://mindon.github.com/blog/categories/mindon/atom.xml" rel="self"/>
  <link href="http://mindon.github.com/"/>
  <updated>2012-07-20T22:48:28+08:00</updated>
  <id>http://mindon.github.com/</id>
  <author>
    <name><![CDATA[Mindon Feng]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Solve NodeJS 0.8 Build Problem]]></title>
    <link href="http://mindon.github.com/blog/2012/07/20/solve-nodejs-0.8-build-problem/"/>
    <updated>2012-07-20T22:04:00+08:00</updated>
    <id>http://mindon.github.com/blog/2012/07/20/solve-nodejs-0.8-build-problem</id>
    <content type="html"><![CDATA[<p>NodeJS before 0.8 is very easy to make &amp; install, which only needs OpenSSL.</p>

<p>But when I tried to update my NodeJS to version 0.8+, problems keep coming...</p>

<p>Here's a few pre-conditions for a successful make of NodeJS v0.8+:</p>

<ol>
<li><p>GNU make 3.8.1+</p></li>
<li><p>Python 2.6 or 2.7</p></li>
<li><p>setenv FLOCK or export FLOCK</p></li>
</ol>


<p>setenv LINK g++ or export LINK=g++</p>

<p>Do remember check issues above when you meet problems building new version of NodeJS.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lost in the Tech Way]]></title>
    <link href="http://mindon.github.com/blog/2012/06/14/lost-in-the-tech-way/"/>
    <updated>2012-06-14T22:40:00+08:00</updated>
    <id>http://mindon.github.com/blog/2012/06/14/lost-in-the-tech-way</id>
    <content type="html"><![CDATA[<p>昨天察觉到的一件事情，在技术开发里可能也是比较容易出现的问题——技术迷失，特此分享和作为自我的警醒。</p>

<p>目标，使用 NodeJS 的 soap 模块，这个模块需要 node-expat 支持。在 windows 下这个模块是比较令人头疼的，虽然周末把这个问题解决了。但是我需要用的两个 WSDL API：登录验证和发邮件，却只调通了登录验证。另外一个用来发邮件提交的xml内容总是不如意，导致调用失败。node-soap模块这个github上的开源模块确实还存在太多问题，还不能处理稍微复杂一点的 WSDL。</p>

<p>因为时间原因，对soap也不太熟悉，想着——如果用这个模块不行，干脆改用 php 或 python，这个有现成的例子——于是，便尝试了一下php和python的调用。自然，API的调用很顺利，而且在 nodejs 调用 php 和 python 也不是什么麻烦的事情。可能大家觉得这样问题就解决了。</p>

<p>当然这个方案貌似没什么问题，能绕过node-soap模块的糟糕表现。可总不是自己想的那样直接用NodeJS处理。不过事情的转折出现在我找 python 例子的过程中：第一个例子是Google到的 suds 模块，用来处理 soap 的，表现不错，达到了效果。不过我却在内部知识分享平台找到了一个python封装好的现成py脚本，却没有用到任何额外模块！这让我感觉到了异常。</p>

<p>于是，大略看了一下另外部门同事分享的python脚本。突然觉醒——自己这些天都迷失在了技术中，而忘记了自己的目标是：成功调用并使用这两个 Web Service API。</p>

<p>这个python脚本是通过把需要提交的xml内容做成字符串模板形式，然后直接用 POST 提交，在HTTP头里指定 SOAPAction。这是针对具体 WSDL 调用的最直接的办法。我折腾了3天却没有想到，完全是脑子不会转弯，迷失在解决技术问题里了，而不是解决真正的问题。</p>

<p>醒了，自然不再需要node-soap，自然就不用管node-expat（虽然已经不是问题），于是按照这个python脚本的思路，花了1+个小时：写代码、封装调试、自测，把原来的登录验证改为新的调用方式。</p>

<p>问题解决了，可这个事情让不断在提“要牢记最终目标是什么”的我无法平静，这个警醒必须是深刻的 —— 切不能迷失在过程之中。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Serve in Multi-Languages]]></title>
    <link href="http://mindon.github.com/blog/2012/06/12/serve-in-multi-languages/"/>
    <updated>2012-06-12T23:00:00+08:00</updated>
    <id>http://mindon.github.com/blog/2012/06/12/serve-in-multi-languages</id>
    <content type="html"><![CDATA[<p>When we want our product -- a webpage for example -- servered in multi-languages, what would we do?</p>

<p>Simple once working method is copy-n-translate:  Making a full copy of original language resource, translate and replace the texts. It's a hard and dirty work.</p>

<p>Unless a few simple pages, no one will do it in this way nowdays.</p>

<p>We like to use text-id and text resources in our projects: desktop applications, J2EE projects, php websites ...</p>

<p>But all of these are working in the same mode: Template + Text-Resources + Tool = Result</p>

<!--more-->


<p><img src="/images/blog/multi-langs.png" alt="" /></p>

<p>(pro: proposition, con: contradition)</p>

<h2>Template</h2>

<ul>
<li><strong>Raw language text as text-resource-id</strong></li>
</ul>


<p>pro: Readable, directly simple, no extra work but replacement. One language file is template itself.</p>

<p>con: Dirty work, if same text appears, you have to manual replace them all.</p>

<h1>q/s#: Could we make maual-process auto?</h1>

<ul>
<li><strong>Named ID as text-resource-id</strong></li>
</ul>


<p>pro: Avoid repeat work on same phrases or sentences.</p>

<p>con: Named IDs' management, unintuitive templates using named IDs.</p>

<h1>q/s#: Could we auto-generate the named IDs and avoid unintuitive templates?</h1>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Build Node-Expat Under Windows]]></title>
    <link href="http://mindon.github.com/blog/2012/06/11/build-node-expat-under-windows/"/>
    <updated>2012-06-11T09:22:00+08:00</updated>
    <id>http://mindon.github.com/blog/2012/06/11/build-node-expat-under-windows</id>
    <content type="html"><![CDATA[<h2>Preparea Developemtn Environment</h2>

<p>To build node-expat module under windows, you need the nodejs addon development env ready.</p>

<ul>
<li><p>Get and install VC++ 2010 Express from microsoft: 【<a href="http://www.microsoft.com/visualstudio/en-us/products/2010-editions/visual-cpp-express">Download VC++ 2010 Express</a>】</p></li>
<li><p>Download and unzip the NodeJS source code from Joyent's github project: 【<a href="https://github.com/joyent/node">Download NodeJS source code</a>】</p></li>
<li><p>Get and install Python 2.7</p></li>
<li><p>Run <code>vcbuild.bat Release</code> under such as <strong>joyen-node/</strong> (where you unzip the source of nodejs) to build NodeJS.</p></li>
</ul>


<h2>Tools for building a NodeJS Module</h2>

<ul>
<li><p>Env variable set <strong>NODE_ROOT</strong>=<em>where-your-joyent-node-located</em></p></li>
<li><p>Check the <strong>tools/</strong> folder in the joyent-node/: file <strong>gyp_addon</strong>, and <strong>addon.gypi</strong> are needed.</p></li>
</ul>


<!--more-->


<p>if they are not exists, try get it from the latest tag from github of joyent-node ( Left of Files tab, find branch --> Tags ).</p>

<p>( You could use tools/<strong>gyp_node</strong> directly )</p>

<h2>Node-Expat Dependencis:</h2>

<ul>
<li><p>Install Expat under windows
<a href="http://sourceforge.net/projects/expat/files/latest/download">http://sourceforge.net/projects/expat/files/latest/download</a></p></li>
<li><p>Env variable set <strong>EXPAT_ROOT</strong>=<em>where-your-Expat-installed</em></p></li>
<li><p>Append the <strong>Bin/</strong> of Expat to <strong>PATH</strong> env.</p></li>
</ul>


<h2>Building Node-Expat:</h2>

<ul>
<li><p>Prepare <strong>build.gyp</strong> ( need to change D:/Expat to your expat root )</p>

<pre><code>{
  'variables' : {
    'target_arch': 'ia32'
  },
  'targets': [
    {
      'target_name': 'node-expat',
      'sources': [ 'node-expat.cc' ],
      'include_dirs': [
    'd:/Expat/Source/lib/'
      ],
      'libraries': [
    '-ld:/Expat/Bin/libexpat.lib'
      ]
    }
  ],
}
</code></pre></li>
<li><p>Run following commands</p></li>
</ul>


<p>to setup build version and msbuild tool env.</p>

<pre><code>@set Configuration=Release
"D:\Microsoft Visual Studio 10.0\VC\vcvarsall.bat"
</code></pre>

<p>then</p>

<pre><code>python d:\joyent-node\tools\gyp_addon build.gyp

msbuild build\build.sln
</code></pre>

<p>Now you should build the Node-Expat. But you may meet other problems:</p>

<h2>Testing</h2>

<p>if run node and require("./build/Release/node-expat") fail, it may be caused by following reasons:</p>

<p><strong>a)</strong>  check the node-expat.cc, and make sure there's a <strong>NODE_MODULE_EXPORT</strong> or <strong>NODE_EXTERN</strong> before the <em>void init</em></p>

<p>something like this: <code>extern "C" NODE_EXTERN void init(Handle&lt;Object&gt; target)</code></p>

<p><strong>b)</strong> if "unable to load shared library" error, try copy <strong>libexpat.dll</strong> to the folder of <strong>node.exe</strong> located.</p>

<ul>
<li> <strong>node test.js</strong></li>
</ul>


<p>if when you run <code>node test.js</code> of expat, it may fail. Then you need following code to fix it.</p>

<pre><code>char *toCString(v8::Local&lt;v8::Value&gt; value, const char *fallback = "") {
    if (value-&gt;IsString()) {
    v8::String::Utf8Value string(value);
    char *str = (char *) malloc(string.length() + 1);
    strcpy(str, *string);
    return str;
    }
    char *str = (char *) malloc(strlen(fallback) + 1);
    strcpy(str, fallback);
    return str;
}
</code></pre>

<p>add these code below <code>using namespace node;</code>.</p>

<p>then change the line around 155 before or 165 after code above added</p>

<pre><code>return XML_ParseBuffer(parser, len, isFinal) != XML_STATUS_ERROR;
</code></pre>

<p> into</p>

<pre><code>return XML_Parse(parser, toCString(&amp;str, ""), len, isFinal) != XML_STATUS_ERROR;
</code></pre>

<p>This patch could help to remove the error "<strong>not well-formed (invalid token)</strong>".</p>

<p>Now, your node-epxat under windows is ready for node-soap, you would need this for something like WSDL!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Final solution]]></title>
    <link href="http://mindon.github.com/blog/2012/05/19/final-solution/"/>
    <updated>2012-05-19T12:21:00+08:00</updated>
    <id>http://mindon.github.com/blog/2012/05/19/final-solution</id>
    <content type="html"><![CDATA[<p><strong>若一切皆可實現，我們會如何解決眼前的問題？</strong>  -- 麥盾</p>

<p>对于这个问题的思考，大概是从讨论行人闯红绿灯过马路的事情开始的。</p>

<p>前段时间看个视频，讨论关于道德的问题，看后同事Carl说道：这类选择本就与道德无关，均是基于自我保护（损害最小）的选择——真是一语道中了问题核心。</p>

<p>至少，若是方圆几里都没车的话，等人行绿灯就是个死板的傻行为，没什么值得称赞的。因为红绿灯系统并不是个很完善的产品。（对于闯红灯的认可，那些不要命想要跟汽车赛跑闯红灯的案例除外）</p>

<p>现在，让我们假设能做到一切，那么红绿灯系统改是怎么样的？</p>

<!--more-->


<p>【理想状态】不会在让人在道路上没车的时候等待！会根据道路的实际状况实时调整状态，让通行效率最高，等待时间最短。</p>

<p>【现实状态】系统没能达到理想状态，而作为行人的本身，却有能力做出调整——如在安全距离没车的情况之下闯人行道红灯——目的是实现通行效率最高，等待时间最短。</p>

<p>奇怪的是没人选择去骂做得并不好的规则和系统，倒是责怪起破坏规定却让系统更有效率的人了。</p>

<p>另外一个事情是在做web产品开发的时候碰到的，就是当一个句子过长的时候如何处理自动换行的问题。常规处理是：一切均自动换行。</p>

<p>咋看起来这样的处理不存在什么问题，现在解剖一下这样的处理方式的实质需求：</p>

<p>【理想状态】在尽量不破坏单词的情况下自动换行，即除非单词超出一行的长度，否则不应该破坏单词。</p>

<p>【现实状态】部分浏览器在自动换行处理上没能达到理想状态，即使单词超出一行的长度，也不自动分行显示。于是，大家干脆采用强制分行显示的方式，即不管长度单词，只要到达的行宽，一律把剩下的字母放到下一行。这样的后果就是很多正常的单词在行末惨遭拆分到两行显示。——问题是，超出行宽的单词少之又少，在一般的行宽内几乎是很难见到的，大多数是非正常输入导致（网址和公式除外）。也就是说这样的处理方式明明是为了极少数的异常输入的正常显示，而不惜去破坏大多数的正常输入的正常显示效果。（新浪微博刚发布的时候我就注意到了存在这样的问题。）</p>

<p>为了兼顾少数异常而不惜损害多数的正常，结果就是导致了更多的另一类异常。类似的情况其实在现实里并不少见。</p>

<p>最典型的就有两个社会现象：</p>

<ol>
<li><strong>计划生育</strong>，最大的问题是死守100年不变。（要說免稅100年不變，大家都是非常歡迎的）</li>
</ol>


<p>这个政策的制定的时候想必是正确的用来纠正之前的政策导致的不可控结果的。如今显得类似对癌之化疗：若是对健康之躯进行化疗，无疑等于谋杀。</p>

<p>现实状态下的政策死守无疑是对中华民族超长期延续的损害。民族基因样本的损失带来的长期破坏会是无法预计和估量的。即为修复短期异常，不惜破坏长期的正常进化和生命发展。</p>

<ol>
<li><strong>房地产市场</strong>，最大问题在对于投机的放任。</li>
</ol>


<p>国家能为了维持一个畸形的房地产市场的稳定，不惜损害广大人民群众的利益、自残信誉、破坏正常的实业发展氛围。——有点上了贼船下不来的感觉，不过更像电影里的一步踏错导致步步错的罪犯。</p>

<p>还有一个案例就是制度制定的现象。</p>

<p>【理想状态】制度规范流程、做法能保证少损失，高效率；</p>

<p>【现实状态】不完善的制度降低了效率，打击了积极性和创造性。典型的就是罚款制度。激励制度的效果相比之下远好于处罚制度，就是说如果规定中的处罚比激励更令人印象深刻的话，可能就需要反思一下了。</p>

<p>处罚只能抑制问题的发生，从来就没能真正解决过问题。法律和监狱就是个最典型的例子了，不过怎么加强处罚，都无法抑制犯罪的发生。</p>

<p>不管是做产品开发，或是制定规章制度，稍微套用一下『<strong>若一切皆可實現，我們會如何解決眼前的問題？</strong>』的思考，然后根据条件做到最近接理想状态的方案，就能避免很多弯路和不必要的问题和争论。</p>

<p>“选择总是基于自我损害最小和自我获利最大的平衡”——这个基本点用来分析和解读很多现象应该也会能找到很多不一样的结果，得到有利于解决问题的办法。</p>

<p>（Oct 17, 2010 <a href="http://mindon.appspot.com/blog/2010/10/16/best-solution.html">若一切都有可能，问题该如何解决？</a>）</p>
]]></content>
  </entry>
  
</feed>
