<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Web-Tech | Mindon.IDEA]]></title>
  <link href="http://mindon.github.com/blog/categories/web-tech/atom.xml" rel="self"/>
  <link href="http://mindon.github.com/"/>
  <updated>2012-03-17T13:35:33+08:00</updated>
  <id>http://mindon.github.com/</id>
  <author>
    <name><![CDATA[Mindon Feng]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[MongoDB: The internal file structure]]></title>
    <link href="http://mindon.github.com/blog/2012/03/17/mongodb-the-internal-file-structure/"/>
    <updated>2012-03-17T11:43:00+08:00</updated>
    <id>http://mindon.github.com/blog/2012/03/17/mongodb-the-internal-file-structure</id>
    <content type="html"><![CDATA[<p><a href="http://www.quora.com/Jared-Rosoff">Jared Rosoff</a></p>

<p>Each logical db has its own set of files in your dbpath. You can find them as <dbname>.<file_number>. If you're using directory-per-db option, then they may be in separate directories.</p>

<p>The dbfiles themselves are broken up into extents. Each extent is assigned to a namespace and contains data for that namespace. Each collection is its own namespace. Also each Index is its own namespace.</p>

<p>Documents in a collection are stored as a doubly linked list within extents. The document itself is formatted as BSON. There is a header that has, among other things, pointers to the next and previous document in the collection.</p>

<p>Index data is also stored in these files, but they are stored as B-Tree's rather than doubly linked lists.</p>

<p>There is also a namespace file that contains namespace (collections, indexes, freelist) meta data and how they map to their extents.</p>

<p>If you're running with journaling enabled, then there is also a set of journal files that contain a history of changes to collection data.</p>

<h2>MongoDB数据文件内部结构</h2>

<p>Origin from <a href="http://blog.nosqlfan.com/html/3515.html">http://blog.nosqlfan.com/html/3515.html</a></p>

<p>有人在Quora上提问：MongoDB数据文件内部的组织结构是什么样的。随后10gen的工程师Jared Rosoff出来做了简短的回答。</p>

<!--more-->


<p>每一个数据库都有自己独立的文件。如果你开启了directoryperdb选项，那你每个库的文件会单独放在一个文件夹里。</p>

<p>数据库文件在内部会被切分成单个的块，每个块只保存一个名字空间的数据。在MongoDB中，名字空间用于区分不同的存储类别。比如每个collection有一个独立的名字空间，每个索引也有自己的名字空间。</p>

<p>在一个块中，会保存多条记录，每条记录是BSON格式的，记录与记录之间通过双向链表进行连接。</p>

<p>索引数据也存在数据文件中，不过索引是被组织成B-Tree结构，而不是双向链表。</p>

<p>对每个数据库，有一个命名空间文件，用于保存每个名字空间对应的元数据。我们通过查询这些元数据来找到对应的名字空间的存储块位置。</p>

<p>如果你开启了jorunaling日志，那么还会有一些文件存储着你所有的操作记录。</p>

<p>下面图片摘自10gen工程师Mathias Stearn在MongoSV2011大会上的发言稿，手绘的数据文件结构。</p>

<ol>
<li><p><strong>每个数据库有相应的数据文件和命名空间文件</strong>
<img src="/images/blog/mongodb-internal/1.jpg" alt="" /></p></li>
<li><p><strong>数据文件从16MB开始，新的数据文件比上一个文件大一倍，最大为2GB</strong>
<img src="/images/blog/mongodb-internal/2.jpg" alt="" /></p></li>
<li><p><strong>文件使用MMAP进行内存映射，会将所有数据文件映射到内存中，但是只是虚拟内存，只有访问到这块数据时才会交换到物理内存。</strong>
<img src="/images/blog/mongodb-internal/3.jpg" alt="" />
<img src="/images/blog/mongodb-internal/3-0.jpg" alt="" /></p></li>
<li><p><strong>MongoDB的数据文件映射到内存表中的位置</strong>
<img src="/images/blog/mongodb-internal/4.jpg" alt="" />
<img src="/images/blog/mongodb-internal/4-0.jpg" alt="" /></p></li>
<li><p><strong>使用32位机器的话，内存地址最大可以标识4GB内存</strong>
<img src="/images/blog/mongodb-internal/5.jpg" alt="" />
<img src="/images/blog/mongodb-internal/5-0.jpg" alt="" /></p></li>
<li><p><strong>但是在32位机器上，4GB内存会有1GB被内核战用，大约0.5GB会用于mongod进程的stack空间，只剩下大约2.5GB可用于映射数据文件。</strong>
<img src="/images/blog/mongodb-internal/6.jpg" alt="" />
<img src="/images/blog/mongodb-internal/6-0.jpg" alt="" /></p></li>
<li><p><strong>在64位机器上则最多可以表示128TB的空间</strong>
<img src="/images/blog/mongodb-internal/7.jpg" alt="" />
<img src="/images/blog/mongodb-internal/7-0.jpg" alt="" />
<img src="/images/blog/mongodb-internal/7-1.jpg" alt="" /></p></li>
<li><p><strong>每个数据文件会被分成一个一个的数据块，块与块之间用双向链表连接</strong>
<img src="/images/blog/mongodb-internal/8.jpg" alt="" />
<img src="/images/blog/mongodb-internal/8.jpg" alt="" /></p></li>
<li><p><strong>在名字空间文件中，保存的是一个hash table，保存了每个名字空间的存储信息元数据，包括其大小，块数，第一块位置，最后一块位置，被删除的块的链表以及索引信息</strong>
<img src="/images/blog/mongodb-internal/9.jpg" alt="" />
<img src="/images/blog/mongodb-internal/9-0.jpg" alt="" /></p></li>
<li><p><strong>这些位置通过DiskLoc数据结构进行存储，存储了数据文件编号和块在文件中的位置</strong>
<img src="/images/blog/mongodb-internal/a.jpg" alt="" />
<img src="/images/blog/mongodb-internal/a-0.jpg" alt="" />
<img src="/images/blog/mongodb-internal/a-1.jpg" alt="" />
<img src="/images/blog/mongodb-internal/a-2.jpg" alt="" /></p></li>
<li><p><strong>对每一个块来说，其头部包含了一些块的元数据，比如自己的位置，上一个和下一个块的位置以及块中第一条和最后一条记录的位置指针。剩下的部分用于存储具体的数据，具体数据之间也是通过双向链接来进行连接。</strong>
<img src="/images/blog/mongodb-internal/b.jpg" alt="" />
<img src="/images/blog/mongodb-internal/b-0.jpg" alt="" />
<img src="/images/blog/mongodb-internal/b-1.jpg" alt="" /></p></li>
<li><p><strong>下面是B-Tree的存储结构和工作原理</strong>
<img src="/images/blog/mongodb-internal/c.jpg" alt="" />
<img src="/images/blog/mongodb-internal/c-0.jpg" alt="" />
<img src="/images/blog/mongodb-internal/c-1.jpg" alt="" />
<img src="/images/blog/mongodb-internal/c-2.jpg" alt="" />
<img src="/images/blog/mongodb-internal/c-3.jpg" alt="" />
<img src="/images/blog/mongodb-internal/c-4.jpg" alt="" />
<img src="/images/blog/mongodb-internal/c-5.jpg" alt="" />
<img src="/images/blog/mongodb-internal/c-6.jpg" alt="" />
<img src="/images/blog/mongodb-internal/c-7.jpg" alt="" /></p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notes on MongoDB]]></title>
    <link href="http://mindon.github.com/blog/2012/03/17/notes-on-mongodb/"/>
    <updated>2012-03-17T11:12:00+08:00</updated>
    <id>http://mindon.github.com/blog/2012/03/17/notes-on-mongodb</id>
    <content type="html"><![CDATA[<p><strong>MongoDB资料汇总专题</strong>
<a href="http://blog.nosqlfan.com/html/3548.html">http://blog.nosqlfan.com/html/3548.html</a></p>

<h2>MongoDB 最佳实践</h2>

<p>Original from <a href="http://www.oschina.net/question/12_38878">http://www.oschina.net/question/12_38878</a></p>

<p><strong>1. 始终启用备份</strong></p>

<p>备份能保证你应用的高可用性。假如你的一个节点down了，第
二节点可以迅速启用，你的应用不会中断。</p>

<p><strong>2. 使用最新版本</strong></p>

<p>10gen在不断的发布更新，特别是2.0.x包含了很高的性能提升
和并行改进，索引改进和bug修复。如果你还在使用 1.6.3的话
，你应该尽快升级。</p>

<!--more-->


<p><strong>3. 不要在32位的系统上跑MongoDB</strong></p>

<p>MongoDB在32位系统上有“2.5GB数据限制”。它的存储引擎使用
内存映射来读取文件以获得更好的性能。这个功能依赖于内存
寻址，而32位系统的内存不能超过4GB。</p>

<p><strong>4. 默认开启日志</strong></p>

<p>MongoDB支持数据库操作的提前日志（write-ahead journaling
）。这个功能有助于灾难恢复。</p>

<p><strong>5. 注意你数据文件的位置</strong></p>

<p>你应该保证你的MongoDB的数据文件是存储在物理驱动器上，例
如 /data/mongodb。当然你也可以使用虚拟的驱动器，但是必
须非常小心。因为它有可能会影响到你的集群架构。我们建议
你使用 Amazon EBS 来存放你的数据库文件。</p>

<p><strong>6. 保证足够大的内存</strong></p>

<p>为了保证整个集群的性能，你要确保整个所有MongoDB的工作实
例（working set）包括索引可以完全装入内存。如果你发现
“page faults”的概率在增加，很有可能mongoDB的数据量超出
了你的内存。在这种情况下你有两种选择：加内存，或者创建
分片集群（Sharding）。我们建议你先考虑加内存。</p>

<p><strong>7. 保持 65% 以内的压力</strong></p>

<p>如果你发现你的集群压力达到了65%，那么你应该考虑扩大你的
集群了。通常，你应该保证数据库压力低于65%。</p>

<p><strong>8. 特别小心分片集群</strong></p>

<p>分片集群需要你充分理解你应用的数据访问方式。你应该充分
了解MongoDB的分片工作方式，并且确认你确实需要这个功能。
还有，选择一个分片钥匙（sharding key）是对于性能也是很
重要的。</p>

<p>配置服务器对于一个集群的健康也是很重要的。在分片集群的
环境中，你必须有三台配置服务器。永远不要删除配置服务器
的数据，时常备份这些数据。这些配置服务器也需要64位的环
境。还有，不要把三台配置服务器放在同一台机器上！</p>

<p><strong>9. 使用 Mongo MMS 来图形化的监控你的数据库</strong></p>

<p>如果你还没有使用 Mongo MMS的话，我强烈推荐这个工具。
10gen 正在大力开发这个产品。它提供了一个非常友好的可视
化的界面来监控你的MongoDB集群。</p>

<p><strong>10. MongoDB 资源</strong></p>

<p>技术总是在不断进步，你需要市场关注这些信息：</p>

<ul>
<li>Documentation: <a href="http://www.mongodb.org/display/DOCS/Home">http://www.mongodb.org/display/DOCS/Home</a></li>
<li>Google Group: <a href="http://groups.google.com/group/mongodb-user">http://groups.google.com/group/mongodb-user</a></li>
<li>Bugs: <a href="https://jira.mongodb.org">https://jira.mongodb.org</a></li>
<li>Blog: <a href="http://blog.mongodb.org/">http://blog.mongodb.org/</a></li>
</ul>


<p><a href="http://www.engineyard.com/blog/2011/mongodb-best-practices/"><strong>MongoDB Best Practices</strong></a> <a href="http://www.programmer.com.cn/9999/">中文</a></p>

<p><strong>MongoDB运行状态、性能监控，分析</strong>:
<a href="http://blog.nosqlfan.com/html/3346.html">http://blog.nosqlfan.com/html/3346.html</a></p>

<p><strong>MongoDB容量规划</strong>:
<a href="http://blog.nosqlfan.com/html/3322.html">http://blog.nosqlfan.com/html/3322.html</a></p>

<p><strong>MongoQ</strong>:
<a href="https://github.com/zzdhidden/mongoq">https://github.com/zzdhidden/mongoq</a></p>

<p><strong>MongoSpy, MongoWatch及MongoDB数据压缩</strong></p>

<p><a href="http://blog.nosqlfan.com/html/3205.html">http://blog.nosqlfan.com/html/3205.html</a></p>

<h2>五步优化你的MongoDB</h2>

<ol>
<li><p><strong>查询优化</strong>
确认你的查询是否充分利用到了索引，用explain命令查看一下查询执行的情况，添加必要的索引，避免扫表操作。</p></li>
<li><p><strong>搞清你的热数据大小</strong>
可能你的数据集非常大，但是这并不那么重要，重要的是你的热数据集有多大，你经常访问的数据有多大（包括经常访问的数据和所有索引数据）。使用MongoDB，你最好保证你的热数据在你机器的内存大小之下，保证内存能容纳所有热数据。</p></li>
<li><p><strong>选择正确的文件系统</strong>
MongoDB的数据文件是采用的预分配模式，并且在Replication里面，Master和Replica Sets的非Arbiter节点都是会预先创建足够的空文件用以存储操作日志。这些文件分配操作在一些文件系统上可能会非常慢，导致进程被Block。所以我们应该选择那些空间分配快速的文件系统。这里的结论是尽量不要用ext3，用ext4或者xfs。</p></li>
<li><p><strong>选择合适的硬盘</strong>
这里的选择包括了对磁盘RAID的选择，也包括了磁盘与SSD的对比选择。</p></li>
<li><p><strong>Shard分片</strong>
在单个节点压力太大时，我们可以考虑使用MongoDB的auto-sharding机制来将数据分片到多个节点以缓解压力。</p></li>
</ol>


<p>火丁筆記: <a href="http://huoding.com/2011/08/09/104">记一次MongoDB性能问题</a></p>

<p><strong>NUMA Problem（Warn)</strong>
<a href="http://www.mongodb.org/display/DOCS/NUMA">http://www.mongodb.org/display/DOCS/NUMA</a></p>

<p>shell> numactl --interleave=all /path/to/mongod</p>

<p>NUMA下，内存是按照物理CPU来划分的，不是按逻辑CPU/核划分的</p>

<p>每个核访问分配给自己的内存会比访问分配给其它核的内存要快，有下面几种访问控制策略：</p>

<ol>
<li><p>缺省(default)：总是在本地节点分配（分配在当前进程运行的节点上）；</p></li>
<li><p>绑定(bind)：强制分配到指定节点上；3.交叉(interleave)：在所有节点或者指定的节点上交织分配；</p></li>
<li><p>优先(preferred)：在指定节点上分配，失败则在其他节点上分配。</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Socket.IO behind proxy or firewall]]></title>
    <link href="http://mindon.github.com/blog/2012/03/06/socket-dot-io-behind-proxy-or-firewall/"/>
    <updated>2012-03-06T06:32:00+08:00</updated>
    <id>http://mindon.github.com/blog/2012/03/06/socket-dot-io-behind-proxy-or-firewall</id>
    <content type="html"><![CDATA[<p>Independently of what transport you are using (WebSocket or Comet or both), a connection can always be closed by a Proxy or Firewall, or an expected network outage can close your connection. Why is it a problem? It’s problematic when a disconnection happens as you may loose server side events if you don’t architect your application correctly.</p>

<ul>
<li><strong>long-polling</strong>: between reconnection, servers side events may happens and if they aren’t persisted, those events will never reach your client.</li>
<li><strong>websocket</strong>: Websocket are new and most if not all firewall will close them after some X idle times. Again, all server sides events will be lost</li>
<li><strong>http-streaming</strong>: Some proxy really don’t like the http-streaming technique, and will close it right away. Again, possibility to loose server sides events.</li>
<li><strong>Unexpected network outage</strong>: the connection can also be closed by something between your browser and server.</li>
</ul>


<!--more-->


<p><a href="https://github.com/LearnBoost/socket.io-client/issues/331">Query string management is messed up</a></p>

<p><a href="https://github.com/LearnBoost/socket.io/wiki/Socket.IO-and-firewall-software">Socket.IO and firewall software</a></p>

<p><a href="http://www.infoq.com/articles/Web-Sockets-Proxy-Servers">How HTML5 Web Sockets Interact With Proxy Servers</a></p>

<p><img src="/images/blog/websocket-proxy.png" alt="Websocket Interact with proxy" /></p>

<blockquote><p>Using TLS/SSL is advised not only when you need to encrypt the traffic but also when you need to bypass proxy servers and firewalls, that otherwise will just block or not understand WebSockets connections.
<a href="http://showmetheco.de/articles/2011/2/diving-into-html5-with-websockets-and-perl.html">Diving into HTML5 with WebSockets and Perl</a></p></blockquote>

<p>Socket.IO server configuring: <strong>match origin protocol</strong></p>

<p><a href="https://github.com/LearnBoost/Socket.IO/wiki/Configuring-Socket.IO">https://github.com/LearnBoost/Socket.IO/wiki/Configuring-Socket.IO</a></p>

<p><a href="http://www.letseehere.com/reverse-proxy-web-sockets">Reverse Proxy Web Sockets with Nginx and Socket.IO</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web-Drawing Throwdown: Paper.js Vs. Processing.js Vs. Raphael]]></title>
    <link href="http://mindon.github.com/blog/2012/02/25/web-drawing-throwdown-paper-dot-js-vs-processing-dot-js-vs-raphael/"/>
    <updated>2012-02-25T23:18:00+08:00</updated>
    <id>http://mindon.github.com/blog/2012/02/25/web-drawing-throwdown-paper-dot-js-vs-processing-dot-js-vs-raphael</id>
    <content type="html"><![CDATA[<p>Before drawing anything in a browser, ask yourself three questions:</p>

<h2>Do you need to support older browsers?</h2>

<p>If the answer is yes, then your only choice is Raphaël. It handles browsers all the way back to IE 7 and Firefox 3. Raphaël even has some support for IE 6, although some of its underlying technology cannot be implemented there.</p>

<h2>Do you need to support Android?</h2>

<p>Android doesn’t support SVG, so you’ll have to use Paper.js or Processing.js. Some rumors say that Android 4 will handle SVG, but the majority of Android devices won’t support it for years.</p>

<h2>Is your drawing interactive?</h2>

<p>Raphaël and Paper.js focus on interaction with drawn elements through clicking, dragging and touch. Processing.js doesn’t support any object-level events, so responding to user gestures is very difficult. Processing.js can draw a cool animation on your home page, but the other tools are better for interactive applications.</p>

<p>Paper.js, Processing.js and Raphaël are the leading libraries for drawing on the Web right now. A couple of others are up and coming, and you can always use Flash, but these three work well with HTML5 and have the widest support among browser vendors.</p>

<p>Choosing the right framework will determine the success of your project. This article covers the advantages and disadvantages of each, and the information you need to make the best choice.</p>

<!--more-->


<p>All of the code in this article is open source and can be run on the demo page that accompanies this article.</p>

<p>[Note: Have you already pre-ordered your copy of our Printed Smashing Book #3? The book is a professional guide on how to redesign websites and it also introduces a whole new mindset for progressive Web design, written by experts in the industry for you. Pre-order now and add your name into the book!]</p>

<h2>Overview</h2>

<table>
<thead>
<tr>
<th> </th>
<th align="center"> Paper.js </th>
<th align="center"> Processing.js </th>
<th align="center"> Raphaël.js</th>
</tr>
</thead>
<tbody>
<tr>
<td>Technology </td>
<td align="center"> canvas tag </td>
<td align="center"> canvas tag </td>
<td align="center"> SVG</td>
</tr>
<tr>
<td>Language </td>
<td align="center"> PaperScript </td>
<td align="center"> Processing script </td>
<td align="center"> JavaScript</td>
</tr>
<tr>
<td>Browsers </td>
<td align="center"> IE 9 </td>
<td align="center"> IE 9 </td>
<td align="center"> IE 7</td>
</tr>
<tr>
<td>Mobile </td>
<td align="center"> Yes </td>
<td align="center"> Yes </td>
<td align="center"> iOS only</td>
</tr>
<tr>
<td>Model </td>
<td align="center"> Vector and raster </td>
<td align="center"> Raster </td>
<td align="center"> Vector</td>
</tr>
<tr>
<td>Size </td>
<td align="center"> 56 KB </td>
<td align="center"> 64 KB </td>
<td align="center"> 20 KB</td>
</tr>
</tbody>
</table>


<p>It’s all JavaScript once the page runs, but the frameworks take different paths to get there. Raphaël is written directly in JavaScript, but Paper.js uses PaperScript, and Processing.js uses its own script. They all support Firefox, Chrome and Safari, but Internet Explorer is an issue — Paper.js and Processing.js use the canvas tag and thus require IE 9.</p>

<p><div style="float:right">
<script type="text/javascript"><!--
google_ad_client = "ca-pub-6997921015773263";
/* git-post-body2 */
google_ad_slot = "9585845910";
google_ad_width = 468;
google_ad_height = 60;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div></p>

<p>PaperScript is a JavaScript extension that makes it possible to write scripts that don’t pollute the global namespace. This cuts down on JavaScript conflicts. PaperScript also supports direct math on objects such as Point and Size: you can add two points together as if they were numbers.</p>

<p>Processing.js is based on a framework named Processing, which runs in the Java Virtual Machine. You define int and float instead of var, and you can use classes with Java-style inheritance. While the Processing.js script looks a little like Java, it’s more like JavaScript and doesn’t require many of the more complex features of Java.
Using all three libraries is easy if you have some familiarity with JavaScript.</p>

<p>Full article could be found from <em>Zack Grossbart</em>'s <a href="http://coding.smashingmagazine.com/2012/02/22/web-drawing-throwdown-paper-processing-raphael/">Web-Drawing Throwdown: Paper.js Vs. Processing.js Vs. Raphael</a></p>

<p>with demos <a href="http://zgrossbart.github.com/3gears/">http://zgrossbart.github.com/3gears/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dive into Node.JS]]></title>
    <link href="http://mindon.github.com/blog/2012/02/22/dive-into-node-dot-js/"/>
    <updated>2012-02-22T15:29:00+08:00</updated>
    <id>http://mindon.github.com/blog/2012/02/22/dive-into-node-dot-js</id>
    <content type="html"><![CDATA[<p>Node.js is a platform built on Chrome's JavaScript runtime for easily building fast, scalable network applications. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices.
<a href="http://nodejs.org">http://nodejs.org</a></p>

<!--more-->


<p>Felix's Node.js Guide
<a href="http://nodeguide.com/">http://nodeguide.com/</a></p>

<ul>
<li><p><a href="http://nodeguide.com/beginner.html">Node.js Beginner Guide</a>
If you are new to node.js, this guide will take you from hello world to deploying your first app.</p></li>
<li><p><a href="http://nodeguide.com/style.html">Node.js Style Guide</a>
The general JavaScript style I recommend to use with node.js. A lot of this is personal preferences, but hopefully rather consistent.</p></li>
<li><p><a href="http://nodeguide.com/community.html">Node.js Community Guide</a>
Get to know some of the node.js community and find out where they hang out.</p></li>
<li><p><a href="http://nodeguide.com/convincing_the_boss.html">Node.js Convincing The Boss Guide</a>
Find out where node.js makes sense, and how to get management to see the benefits.</p></li>
</ul>


<p>NodeJS – The what, why, how and when
<a href="http://blog.xebia.com/2011/08/16/nodejs-the-what-why-how-and-when/">http://blog.xebia.com/2011/08/16/nodejs-the-what-why-how-and-when/</a></p>
]]></content>
  </entry>
  
</feed>
